# Nom du workflow qui s'affichera dans l'onglet "Actions" de votre dépôt GitHub.
name: Build and Push Docker Image ARM64 & AMD64

# Déclencheurs du workflow.
on:
  # Se déclenche automatiquement à chaque push sur la branche "main".
  push:
    branches:
      - "main"
  # Permet de déclencher manuellement le workflow depuis l'interface de GitHub.
  workflow_dispatch:

# Liste des jobs à exécuter.
jobs:
  # Nom du job.
  build-and-push:
    # Skip si le message contient [skip ci], [ci skip], etc.
    if: "!contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[ci skip]')"
    # Machine virtuelle sur laquelle le job va s'exécuter.
    runs-on: ubuntu-latest
    # Permissions nécessaires pour ce job.
    permissions:
      contents: write  # Permission de lire ET écrire le contenu (pour commiter la nouvelle version).
      packages: write  # Permission d'écrire des packages (pour publier l'image sur ghcr.io).

    # Étapes du job.
    steps:
      # 1. Récupère le code source de votre dépôt.
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Récupère les 2 derniers commits pour comparer

      # 2. Se connecte au GitHub Container Registry (ghcr.io).
      - name: Log in to the GitHub Container Registry

        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          # Le nom d'utilisateur est le propriétaire du dépôt, forcé en minuscules.
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 4. Configure QEMU pour l'émulation ARM64
      - name: Set up QEMU

        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      # 5. Met en place Docker Buildx avec plateformes optimisées
      - name: Set up Docker Buildx

        uses: docker/setup-buildx-action@v3

      # 6. Prépare les métadonnées de l'image (nom en minuscule + version sémantique auto-incrémentée).
      - name: Prepare image metadata

        run: |
          IMAGE_NAME=$(echo "${GITHUB_REPOSITORY}" | tr '[:upper:]' '[:lower:]')
          
          # Lit la version actuelle
          CURRENT_VERSION=$(cat VERSION)
          
          # Découpe la version en MAJOR.MINOR.PATCH
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Cas spécial : 0.0.0 → 1.0.0 (initialisation)
          if [ "$CURRENT_VERSION" = "0.0.0" ]; then
            NEW_VERSION="1.0.0"
          # Cas spécial : X.9.999 → (X+1).0.0 (changement majeur)
          elif [ "$MINOR" = "9" ] && [ "$PATCH" = "999" ]; then
            NEW_MAJOR=$((MAJOR + 1))
            NEW_VERSION="${NEW_MAJOR}.0.0"
          # Cas spécial : X.Y.999 → X.(Y+1).0 (changement mineur)
          elif [ "$PATCH" = "999" ]; then
            NEW_MINOR=$((MINOR + 1))
            NEW_VERSION="${MAJOR}.${NEW_MINOR}.0"
          else
            # Incrémentation normale du PATCH
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
          fi
          
          # Sauvegarde la nouvelle version
          echo "$NEW_VERSION" > VERSION
          
          echo "IMAGE_NAME=${IMAGE_NAME}" >> "$GITHUB_ENV"
          echo "IMAGE_VERSION=v${NEW_VERSION}" >> "$GITHUB_ENV"
          echo "IMAGE_VERSION_SHORT=${NEW_VERSION}" >> "$GITHUB_ENV"
          echo "OLD_VERSION=${CURRENT_VERSION}" >> "$GITHUB_ENV"
          
          echo "✅ Version incrémentée : ${CURRENT_VERSION} → ${NEW_VERSION}"
      
      # 7. Commite la nouvelle version dans le dépôt
      - name: Commit new version

        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add VERSION
          git commit -m "chore: bump version ${{ env.OLD_VERSION }} → ${{ env.IMAGE_VERSION_SHORT }} [skip ci]" || echo "No changes to commit"
          git push || echo "Nothing to push"

      # 8. Génère le Dockerfile à partir du template et du fichier de configuration.
      - name: Generate Dockerfile

        run: python3 generate_dockerfile.py

      # 9. Construit l'image Docker et la publie sur le GitHub Container Registry.
      - name: Build and push Docker image

        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ghcr.io/${{ env.IMAGE_NAME }}:latest
            ghcr.io/${{ env.IMAGE_NAME }}:${{ env.IMAGE_VERSION }}
          # Cache désactivé pour toujours récupérer les derniers correctifs de sécurité
          # apt-get upgrade -y dans le Dockerfile nécessite un build sans cache
          no-cache: true
          # Supprimer métadonnées supplémentaires
          provenance: false
          sbom: false
  # ============================================================
  # JOB DE NETTOYAGE : Supprime les images untagged orphelines
  # ============================================================
  cleanup:
    needs: build-and-push
    if: success()
    runs-on: ubuntu-latest
    permissions:
      packages: write
    
    steps:
      - name: Delete old untagged images
        uses: actions/delete-package-versions@v5
        with:
          package-name: ${{ github.event.repository.name }}
          package-type: 'container'
          min-versions-to-keep: 0
          delete-only-untagged-versions: 'true'
