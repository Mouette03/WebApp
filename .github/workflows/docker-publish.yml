# Nom du workflow qui s'affichera dans l'onglet "Actions" de votre d√©p√¥t GitHub.
name: Build and Push Docker Image ARM64 & AMD64

# D√©clencheurs du workflow.
on:
  # Se d√©clenche automatiquement √† chaque push sur la branche "main".
  push:
    branches:
      - "main"
  # Permet de d√©clencher manuellement le workflow depuis l'interface de GitHub.
  workflow_dispatch:

# Liste des jobs √† ex√©cuter.
jobs:
  # Nom du job.
  build-and-push:
    # Machine virtuelle sur laquelle le job va s'ex√©cuter.
    runs-on: ubuntu-latest
    # Permissions n√©cessaires pour ce job.
    permissions:
      contents: write  # Permission de lire ET √©crire le contenu (pour commiter la nouvelle version).
      packages: write  # Permission d'√©crire des packages (pour publier l'image sur ghcr.io).

    # √âtapes du job.
    steps:
      # 1. R√©cup√®re le code source de votre d√©p√¥t.
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # R√©cup√®re les 2 derniers commits pour comparer
      
      # 2. V√©rifie si le dernier commit contient [skip ci] et arr√™te le job si c'est le cas
      - name: Check if should skip CI
        id: check_skip
        run: |
          COMMIT_MSG=$(git log -1 --pretty=%B)
          if echo "$COMMIT_MSG" | grep -q "\[skip ci\]"; then
            echo "üõë CI skipped - commit message contains [skip ci]"
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ CI will run"
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      # 3. Se connecte au GitHub Container Registry (ghcr.io).
      - name: Log in to the GitHub Container Registry
        if: steps.check_skip.outputs.skip != 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          # Le nom d'utilisateur est le propri√©taire du d√©p√¥t, forc√© en minuscules.
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 4. Configure QEMU pour l'√©mulation ARM64
      - name: Set up QEMU
        if: steps.check_skip.outputs.skip != 'true'
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      # 5. Met en place Docker Buildx avec plateformes optimis√©es
      - name: Set up Docker Buildx
        if: steps.check_skip.outputs.skip != 'true'
        uses: docker/setup-buildx-action@v3

      # 6. Pr√©pare les m√©tadonn√©es de l'image (nom en minuscule + version s√©mantique auto-incr√©ment√©e).
      - name: Prepare image metadata
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          IMAGE_NAME=$(echo "${GITHUB_REPOSITORY}" | tr '[:upper:]' '[:lower:]')
          
          # Lit la version actuelle
          CURRENT_VERSION=$(cat VERSION)
          
          # D√©coupe la version en MAJOR.MINOR.PATCH
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Incr√©mente le PATCH
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
          
          # Sauvegarde la nouvelle version
          echo "$NEW_VERSION" > VERSION
          
          echo "IMAGE_NAME=${IMAGE_NAME}" >> "$GITHUB_ENV"
          echo "IMAGE_VERSION=v${NEW_VERSION}" >> "$GITHUB_ENV"
          echo "IMAGE_VERSION_SHORT=${NEW_VERSION}" >> "$GITHUB_ENV"
          echo "OLD_VERSION=${CURRENT_VERSION}" >> "$GITHUB_ENV"
          
          echo "‚úÖ Version incr√©ment√©e : ${CURRENT_VERSION} ‚Üí ${NEW_VERSION}"
      
      # 7. Commite la nouvelle version dans le d√©p√¥t
      - name: Commit new version
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add VERSION
          git commit -m "chore: bump version ${{ env.OLD_VERSION }} ‚Üí ${{ env.IMAGE_VERSION_SHORT }} [skip ci]" || echo "No changes to commit"
          git push || echo "Nothing to push"

      # 8. G√©n√®re le Dockerfile √† partir du template et du fichier de configuration.
      - name: Generate Dockerfile
        if: steps.check_skip.outputs.skip != 'true'
        run: python3 generate_dockerfile.py

      # 9. Construit l'image Docker et la publie sur le GitHub Container Registry.
      - name: Build and push Docker image
        if: steps.check_skip.outputs.skip != 'true'
        uses: docker/build-push-action@v5
        with:
          no-cache: true
          context: .
          file: ./dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ghcr.io/${{ env.IMAGE_NAME }}:latest
            ghcr.io/${{ env.IMAGE_NAME }}:${{ env.IMAGE_VERSION }}
          # Cache optimis√© pour acc√©l√©rer les builds
          cache-from: type=gha
          cache-to: type=gha,mode=max
          # Supprimer images untagged
          provenance: false
          sbom: false
  # ============================================================
  # JOB DE NETTOYAGE : Supprime les images untagged orphelines
  # ============================================================
  cleanup:
    needs: build-and-push
    runs-on: ubuntu-latest
    permissions:
      packages: write
    
    steps:
      - name: Delete old untagged images
        uses: actions/delete-package-versions@v5
        with:
          package-name: ${{ github.event.repository.name }}
          package-type: 'container'
          min-versions-to-keep: 0
          delete-only-untagged-versions: 'true'
